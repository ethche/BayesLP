# primal methods
import numpy as np
import scipy.optimize as opt

# primal solver
def bayes_primal(program):
    """
    Sets up the primal program given the parameters specified in program
    INPUT
        program (BayesLP) class instance that contains parameters of the
            problem.
    RETURNS
        constraints (dict) contains the constraints of the Bayes LP problem,
            which are the required marginal distributions of the optimal mechanism.
            prior (n x 1 array) the prior distribution of the states.
            ic_constraint (n x 1 array) an array of 0s indicating the receiver's
                expected utility in each state
            value_mat (n x n array) the expected utility obtained by the sender
                under the optimal mechanism.
        primal (dict) contains results of the primal LP:
            mechanism (n x n array) joint probability distribution between states
                and messages.
        dual (dict) contains results of the dual LP:

    """

    # Load program parameters.
    # Set up the grid.
    n = program.n
    interval = program.interval
    grid = np.linspace(interval[0], interval[1], n)

    # Vectorize functions
    prior_vec = np.vectorize(program.prior)
    u_vec     = np.vectorize(program.u)
    g_vec     = np.vectorize(program.g)
    v_vec     = np.vectorize(program.v)

    ## Constraints

    # Bayes-plausibility constraint
    # This is the prior distribution evaluated on the vector of states
    prior = prior_vec(grid)
    # Normalize prior distribution
    if sum(prior) != 1.:
        prior = np.divide(prior, sum(prior))

    # Incentive compatibility constraint
    ic_constraint = np.zeros(n)
    # Concatenate constraint realizations as a (2n x 1 array)
    b = np.concatenate((prior, ic_constraint), axis = 0)

    # Create a matrix of sender's utilities for different
    # (state, message) combinations.
    V_mat = np.ndarray(shape = (n,n))
    for j in range(n):
        V_mat[:,j] = v_vec(grid,grid[j])
    # Reshape to an n^2 array, the cost vector in the LP
    V = V_mat.reshape((n**2))
    # negative, so that linprog will return a maximum
    V = -V

    # The "transportation" matrix, which defines the projections
    # on the state space and the message space.
    ones = np.ones(n)
    ones_T = ones.reshape((n,1))

    # The rows of the transpose of the transportation matrix correspond
    # with the projection on state space.
    state_space_proj = np.kron(np.eye(n), ones_T)

    # The columns of the transpose of the A matrix correspond
    # with the sender's expected utility from the posterior generated by the
    # mechanism, and the sender's private information (averaged over all states).
    # This is made to equal 0 in the program (this is the IC constraint,
    # the sender has an expected utility of 0).
    ic_msg_proj = []
    for i in range(n):
        postr_utility = u_vec(grid[i], grid) * g_vec(grid[i], grid)
        postr_utility_mat = np.diag(postr_utility)

        if i == 0:
            ic_msg_proj = postr_utility_mat
        else:
            ic_msg_proj = np.vstack((ic_msg_proj, postr_utility_mat))

    # Stack the state space projection and the column space projection
    # horizontally. Then take the transpose.
    transport_T = np.hstack((state_space_proj, ic_msg_proj))
    transport   = transport_T.T

    # Solve with linprog
    bp_lin_prog = opt.linprog(V, A_eq = transport, b_eq = b)

    # Recover joint probability distribution
    phi = bp_lin_prog.x.reshape((n,n))

    # Normalize (although this should not be necessary), since the prior
    # distribution is normalized to 1.
    phi = np.divide(phi, phi.sum())

    value_matrix = -V
    value_matrix = value_matrix.reshape((n, n))

    # Save parameters of the problem
    params = {"grid": grid,
              "value_mat": value_matrix,
              "prior": prior,
              "ic_constraint": ic_constraint}

    # Save solutions
    solutions = {"primal": phi,
                 "dual": }

    return (params, solutions)

# Dual solver
#def bayes_dual(program):
